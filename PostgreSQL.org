#+TITLE: 简明 PostgreSQL
#+LANGUAGE: zh-CN
#+AUTHOR: [[https://github.com/shynur][/谢骐/]]
#+HTML_HEAD: <style> table, th, td {border: 1px solid;} code {box-sizing: border-box; display: inline-block; background-color: #F3F5F9; color: #0ABF5B} </style>

* 使用 ~psql~
** 打开 ~psql~

在 shell 中运行安装时自带的 ~runpsql.bat~[fn:: 本文以 MS-Windows 为例.] 即可, e.g.,

#+BEGIN_SRC pwsh
~shynur/bin/PostgreSQL/16/scripts/runpsql.bat
#+END_SRC

** 退出 ~psql~

可直接叉掉窗口, 或

#+BEGIN_SRC sql
database_name=# \q
#+END_SRC

* SQL 概要
** 三类语句
*** DDL[fn:DDL: Data Definition Language]

| ~CREATE~                | ~DROP~ | ~ALTER~ |
|-------------------------+--------+---------|
| *创建* 数据库, 表, etc. | *删除* | *修改*  |

*** DML[fn:DML: Data Manipulation Language]

| ~SELECT~           | ~INSERT~               | ~UPDATE~           | ~DELETE~           |
|--------------------+------------------------+--------------------+--------------------|
| *查询*​表中的数据 | 向表中​*插入*​新数据 | *更新*​表中的数据 | *删除*​表中的数据 |

*** DCL[fn:DCL: Data Control Language]

- 确认​/​取消对数据库中的数据进行的​*变更*
  | ~COMMIT~ | ~ROLLBACK~ |
  |----------+------------|
  | *确认*   | *取消*     |
- *设定* RDBMS 中​*用户*​操作数据库中的对象 (e.g., 表) 的​*权限*
  | ~GRANT~            | ~REVOKE~ |
  |--------------------+----------|
  | *赋予*​用户操作权限 | *取消*   |

** 基本书写规则

- 语句以 分号 (‘​=;=​’) 结尾
- /字符串/​&​/日期/​这两类常数须用 单引号 (‘​='=​’) 扩起

** 命名约定

- 数据库的名字, 表名, 和列名 只能使用:
  - 字母
  - 数字
  - 下划线 (‘​=_=​’)
- 名称必须​*以​_字母_​开头*
- 数据库的名字只能使用​_小写字母_

* 创建数据库与表
** 数据库的创建

#+BEGIN_SRC sql
-- 创建名为 ‘shop’ 的数据库.
CREATE DATABASE shop;
#+END_SRC

** 表的创建

#+BEGIN_SRC sql
-- 在数据库 ‘shop’ 中创建名为 ‘Products’ 的表.
CREATE TABLE Products (
  -- 列名        数据类型     [约束]
  product_id        CHAR(4)   NOT NULL,
  product_name   VARCHAR(100) NOT NULL,
  product_type   VARCHAR(32)  NOT NULL,
      sale_price INTEGER              ,
  purchase_price INTEGER              ,
  regist_date    DATE                 ,
  -- 除了 ‘NOT NULL’, 其余约束可在末尾设置:
  PRIMARY KEY (product_id)
);
#+END_SRC

执行以下代码[fn:Mick_Copyright: 摘编自 /Mick/ 的著作 /SQL 基础教程/ (ISBN 978-7-115-45502-4), 版权归 /Mick/.][fn:BEGIN_TRANSACTION: 对于 ~BEGIN TRANSACTION;~ 这行, 在 MySQL 中使用 ~START TRANSACTION;~; 在 Oracle 和 DB2 中不需要这句.]以插入本文使用的示例数据:

#+NAME: CREATE TABLE Products
#+BEGIN_SRC sql
BEGIN TRANSACTION;     /* product_id         product_type    purchase_price
                              |   product_name    |    sale_price  |   regist_date */
INSERT INTO Products VALUES('0001', 'T恤衫'  , '衣服'    , 1000,  500, '2009-09-20');
INSERT INTO Products VALUES('0002', '打孔器' , '办公用品',  500,  320, '2009-09-11');
INSERT INTO Products VALUES('0003', '运动T恤', '衣服'    , 4000, 2800,         NULL);
INSERT INTO Products VALUES('0004', '菜刀'   , '厨房用具', 3000, 2800, '2009-09-20');
INSERT INTO Products VALUES('0005', '高压锅' , '厨房用具', 6800, 5000, '2009-01-15');
INSERT INTO Products VALUES('0006', '叉子'   , '厨房用具',  500, NULL, '2009-09-20');
INSERT INTO Products VALUES('0007', '擦菜板' , '厨房用具',  880,  790, '2008-04-28');
INSERT INTO Products VALUES('0008', '圆珠笔' , '办公用品',  100, NULL, '2009-11-11');
COMMIT;
#+END_SRC

*** 数据类型
**** INTEGER

存储整数.

**** CHAR

存储​*定长字符串*, 用法: ~CHAR(最大长度)~.
不同的 RDBMS 可能使用不同的长度单位 (e.g., 字符[fn:: 一个字符通常需要 1​-​3 bytes 来表示.]个数, 字节数).

当要被存储的字符串长度小于最大长度时, 会使用​_空格_​补足.
E.g., 向 ~CHAR(3)~ 类型的列中输入 ='ab'= 时, 实际存储的是 ='ab '=.

**** <<VARCHAR>>VARCHAR[fn:: Oracle[fn:: 本文在介绍 PostgreSQL 的同时, 也会将其与 Oracle Database, SQL Server, DB2, 和 MySQL 进行对比.  若无特别声明, 前述的 \(4\) 个 RDBMS 以及 PostgreSQL 皆可正常执行文中的示例代码.] 中使用 VARCHAR2 型.  (Oracle 中也有 VARCHAR 型, 但并不推荐使用.)]

存储​*变长字符串*, 和 [[*CHAR][CHAR]] 型的区别是: *不会*​使用​_空格_​补足.
E.g., 向 ~VARCHAR(3)~ 类型的列中输入 ='ab'= 时, 实际存储的还是它.

**** DATE

存储​_年月日_[fn:: Oracle 中的 DATE 型还包含​_时分秒_.].

*** 约束
**** ~NULL~

能否输入空白.

**** ~KEY~

所谓键, 就是在指定特定数据时使用的列的组合.

***** ~PRIMARY KEY~
* 表的删除与更新
** 删除表

#+BEGIN_SRC sql
-- 删除 ‘Products’ 表.
DROP TABLE Products;
#+END_SRC

N.b., 删除的表是无法恢复的.
只能重新创建, 然后重新插入数据.

** 更新表的定义

N.b., ~ALTER TABLE~ 语句和 [[*删除表][~DROP TABLE~ 语句]]一样, 执行之后无法恢复.
误添的列可以通过 ~ALTER TABLE~ 语句删除, 或者将表全部删除之后再重新创建.

*** 添加列

#+BEGIN_SRC sql
-- 给 ‘Products’ 表添加一列, 表示商品名称的拼音.
ALTER TABLE Products
ADD COLUMN product_name_pinyin VARCHAR(100);
#+END_SRC

Oracle 中的写法[fn:Oracle增删单列: Oracle 可一次性增删多列.  当仅涉及 \(1\) 列的增删时, 可省略左右的括号.]:
 : ALTER TABLE Products ADD (product_name_pinyin VARCHAR2(100), 更多的新列, ...);
SQL Server 中的写法:
 : ALTER TABLE Products ADD product_name_pinyin VARCHAR(100);
它们都省略了 ~COLUMN~ 关键字.

*** 删除列

#+BEGIN_SRC sql
-- 删除 ‘Products’ 表中的 ‘product_name_pinyin’ 列.
ALTER TABLE Products
DROP COLUMN product_name_pinyin;
#+END_SRC

Oracle 中的写法[fn:Oracle增删单列]:
 : ALTER TABLE Products DROP (product_name_pinyin, 更多的旧列, ...);

* 查询 (query)
** 列的查询
*** 查询指定的列

基本的 ~SELECT~ 语句:

#+BEGIN_SRC sql
SELECT product_name,  -- 查询结果中 column 的顺序
       sale_price     -- 与此处指定的顺序一致.
FROM Products;
#+END_SRC

包含了 ~SELECT~ 和 ~FROM~ 两个子句 (clause).

*** 查询所有列

#+BEGIN_SRC sql
SELECT * FROM Products;
#+END_SRC

但这样就无法设定列的显示顺序了, 这时就会按创建表时使用的 [[*表的创建][~CREATE TABLE~]] 对列进行排序.

*** 为列取别名

#+BEGIN_SRC sql
  SELECT product_id     AS id,
         product_name   AS "商品名",
         purchase_price AS "价  格"
  FROM Products;
#+END_SRC

使用双引号[fn:: N.b., 不是单引号.]可以包含空格, 取中文别名, etc.

*** 常数的查询

#+BEGIN_SRC sql
  SELECT '商品'        -- 字符串常数
           AS goods,
         42            -- 数字常数
           AS "the answer to the universe",
         '2023-12-03'  -- 日期常数
           AS "today’s date",
         product_name
  FROM Products;
#+END_SRC

使用​/字符串/​/​/日期/​常数时, 必须用单引号 (='=) 将其括起.

** 筛选
*** 去重

#+NAME: SELECT_DISTINCT的用法
#+BEGIN_SRC sql
SELECT DISTINCT purchase_price
FROM Products;
#+END_SRC

这个示例说明, 在使用 ~DISTINCT~ 时, ~NULL~ 也被视为一类数据.
I.e., 当 ~NULL~ 存在于多行中时, 也会被合并为一条 ~NULL~ 数据.

对单列的结果去重, 本质上是对多列组合的去重的特殊情形.

#+BEGIN_SRC sql
SELECT DISTINCT product_type,
                regist_date
FROM Products;
#+END_SRC

查询结果中的行与行之间, 如果​/各列数据都是重复的/, 那么就会被合并为一条.
所以 /~DISTINCT~ 关键字只能用在第一个列名之前/.

*** 过滤条件

#+BEGIN_SRC sql
SELECT product_name
FROM Products
WHERE product_type = '衣服';
#+END_SRC

N.b., ~WHERE~ 子句必须​/紧跟/​在 ~FROM~ 子句之后[fn:SQL书写顺序: *SQL 中子句的书写顺序是固定的!*].

** 数学运算符
*** 算术运算符

可使用四则运算, e.g.,

#+BEGIN_SRC sql
  SELECT product_name,
         (sale_price + 50) * 0.5 AS "近乎半价"
  FROM Products;
#+END_SRC

**** 含 ~NULL~ 的计算

*所有包含 ~NULL~ 的计算, 结果肯定是 ~NULL~.*
E.g.,

#+BEGIN_SRC sql
  SELECT 1 + NULL,
         1 * NULL,
         1 / NULL,
         NULL / 0;
#+END_SRC

通常情况下, 类似 ~1/0~ 这样除数为 \(0\) 会发生错误, 只有像上述示例代码[fn:: 实际上 ~FROM~ 子句在 ~SELECT~ 语句中并不是必不可少的, 可以只使用 ~SELECT~ 子句, 当成一个简陋的计算器.  但是, 在 Oracle 中, ~FROM~ 子句是必须的, 不过可以用 ~DUAL~ 这个临时表; 而在 DB2 中, 可以使用 ~SYSIBM.SYSDUMMY1~ 这个临时表.]这样用 \(0\) 除 ~NULL~ 不会发生错误.

*** 比较运算符

有 ~<~, ~<=~, ~=~, ~>=~, ~>~, 和 ~<>~[fn:: 有很多 RDBMS 把 ~!=~ 作为该运算符的同义词, 但这是不被标准 SQL 所承认的.] 这些.

#+BEGIN_SRC sql
  SELECT product_name
  FROM Products
  WHERE sale_price - purchase_price >= 500;
#+END_SRC

#+BEGIN_SRC sql
  SELECT product_name, regist_date
  FROM Products
  -- 选取出登记日期_早于_ 2009 年 9 月 27 日的记录.
  WHERE '2009-09-27' > regist_date;
#+END_SRC

N.b., 字符串类型[fn:: 该规则对[[*CHAR][定长字符串]]和[[VARCHAR][可变长字符串]]都适用.]的数据原则上按照字典顺序进行排序, 不能与数字​/​日期的大小顺序混淆.

**** 含 ~NULL~ 的比较

还记得 “叉子” 和 “圆珠笔” 的进货单价 (=purchase_price=) 是 ~NULL~ 吗?[fn:CREATE_TABLE_Products: 参见 [[CREATE TABLE Products][=Products= 的建表语句]].]
我们来尝试根据 =purchase_price= 进行选取:

#+BEGIN_SRC sql
  SELECT product_name
  FROM Products
  -- 即使删去下面两行中的注释符, 还是不能选出进价为 NULL 的商品.
  WHERE /* NOT ( */ purchase_price = 2800
        OR purchase_price <> 2800 /* ) */;
#+END_SRC

执行结果中并没有 “叉子” 和 “圆珠笔”.
因为这两件商品的进货单价不明 (~NULL~), 所以无法判定是不是指定的价格.[fn:: 更具体的分析, [[真值表][参见后文]]]
不过, SQL 提供了专门用来判断是否为 ~NULL~ 的 ~IS NULL~ 和 ~IS NOT NULL~ 运算符, e.g.,

#+BEGIN_SRC sql
  SELECT product_name
  FROM Products
  WHERE purchase_price IS NULL;
#+END_SRC

*** 逻辑运算符

有 ~AND~, ~OR~, 和 ~NOT~ 这些.
N.b., /~AND~ 的​_结合性_​强于 ~OR~/.

[[*含 ~NULL~ 的比较][前文]]中介绍了查询 ~NULL~ 时不该使用 ~=~​/​~<>~; 实际上, 使用逻辑运算符时也需要特别对待 ~NULL~.
因为 SQL 中与 ~NULL~ 比较的结果是不确定 (UNKNOWN), 所以:

#+NAME: 真值表
#+CAPTION: _三值逻辑_​中的 ~AND~ 和 ~OR~ 真值表
| $P$     | $Q$     | ~AND~   | ~OR~    |
|---------+---------+---------+---------|
| 真      | 真      | 真      | 真      |
| 真      | 假      | 假      | 真      |
| 真      | unknown | unknown | 真      |
| 假      | 假      | 假      | 假      |
| 假      | unknown | 假      | unknown |
| unknown | unknown | unknown | unknown |

* 聚合与分组
** 聚合函数

所谓​/聚合/, 就是将多行汇总为一行; 用于计算汇总的数据的函数称为​_聚合函数_.

*** 常用的聚合函数
**** ~COUNT~ 函数

*聚合函数通常会对 non-~NULL~ 的对象进行汇总*, 但是只有 _~COUNT(*)~_ 是例外.
它可以查出包含 ~NULL~ 在内的全部数据的行数, e.g.,

#+BEGIN_SRC sql
  SELECT COUNT(*) AS "表的行数",
         COUNT(purchase_price) AS "进价列非空的行数"
  FROM Products;
#+END_SRC

该特性是 ~COUNT~ 函数所特有的, *其它函数并不能将 =*= 作为参数!*

**** ~SUM~ 函数

#+BEGIN_SRC sql
  SELECT SUM(sale_price),
         SUM(purchase_price)  -- 该列含 NULL.
  FROM Products;
#+END_SRC

注意 =purchase_price= 列中含 ~NULL~, 我们来看下 PostgreSQL 是如何计算 ~SUM(purchase_price)~ 的:

| T恤衫 | 打孔器 | 运动T恤 | 菜刀 | 高压锅 | 叉子   | 擦菜板 | 圆珠笔 | 合计 |
|-------+--------+---------+------+--------+--------+--------+--------+------|
|   500 |    320 |    2800 | 2800 |   5000 | +NULL+ |    790 | +NULL+ |      |
#+TBLFM: $9=$1+$2+$3+$4+$5+$7

前文说过: “[[*含 ~NULL~ 的计算][所有包含 ~NULL~ 的计算, 结果肯定是 ~NULL~.]]”
但我们看到, 这里的结果并非 ~NULL~, 这说明:

#+BEGIN_CENTER
所有的聚合函数, 如果以列名为参数, 那么在计算之前就已经把 ~NULL~ 排除在外了.
因此, 无论有多少个 ~NULL~ 都会被无视.
这与“等价为 \(0\)”并不相同.
#+END_CENTER

**** TODO [0%] ~AVG~ 函数

#+BEGIN_SRC sql
  SELECT AVG(purchase_price)
  FROM Products;
#+END_SRC

计算时对待 ~NULL~ 的方式类似 [[*~SUM~ 函数]]:

| T恤衫 | 打孔器 | 运动T恤 | 菜刀 | 高压锅 | 叉子   | 擦菜板 | 圆珠笔 | 合计 \div 6 |
|-------+--------+---------+------+--------+--------+--------+--------+-------------|
|   500 |    320 |    2800 | 2800 |   5000 | +NULL+ |    790 | +NULL+ |       2035. |
#+TBLFM: $9=($1+$2+$3+$4+$5+$7)/6.0

- [ ] 但是有时也想将 ~NULL~ 作为 \(0\) 进行计算:

 | T恤衫 | 打孔器 | 运动T恤 | 菜刀 | 高压锅 | 叉子     | 擦菜板 | 圆珠笔   | 合计 \div 8 |
 |-------+--------+---------+------+--------+----------+--------+----------+-------------|
 |   500 |    320 |    2800 | 2800 |   5000 | +NULL+ 0 |    790 | +NULL+ 0 |     1526.25 |
 #+TBLFM: $9=($1+$2+$3+$4+$5+$7)/8.0

 这是有办法做到的.

**** TODO ~MIN~ 函数和 ~MAX~ 函数

同样地, 这两个函数预先排除了 ~NULL~:

#+BEGIN_SRC sql
  SELECT MIN(sale_price),
         MAX(purchase_price)
  FROM Products;
#+END_SRC

N.b., ~MIN~​/​~MAX~ 函数 跟 ~AVG~​/​~SUM~ 函数 对参数类型有不同的要求:
~AVG~​/​~SUM~ 函数只能对​_数值类型_​的列使用, 而 ~MIN~​/​~MAX~ 函数原则上可以用于​_任何数据类型_​的列.
E.g.,

# TODO 不知为何, 该代码块的结果没有被导出.
#+BEGIN_SRC sql :exports both
  SELECT MIN(regist_date),
         MAX(regist_date)
  FROM Products;
#+END_SRC

#+RESULTS:
|        min |        max |
|------------+------------|
| 2008-04-28 | 2009-11-11 |

只要是能够排序的数据, 就肯定有最值, 也就能够使用这俩函数.
对日期来说, 平均值 和 合计值 并没有实际意义, 因此不能使用 ~AVG~​/​~SUM~ 函数.
这个观点对于字符串类型的数据也适用.

*** 向聚合函数传入互异的参数

#+CAPTION: 计算去重后的数据行数
#+BEGIN_SRC sql
  SELECT COUNT(DISTINCT product_type) AS "品类数目"
  FROM Products;
#+END_SRC

#+RESULTS:
| 品类数目 |
|------------|
| 3        |

这里 ~DISTINCT~ 写在括号中, 是因为必须要在计算行数之前删除 =product_type= 列中的重复数据.
如果像[[SELECT_DISTINCT的用法][~SELECT DISTINCT~ 语句]]那样写在括号外的话, 就会先计算出数据行数, 再删除重复数据, 最终得到的是 =product_type= 列的所有行数:

#+CAPTION: 先计算行数, 再删除重复的结果
#+BEGIN_SRC sql
  SELECT DISTINCT COUNT(product_type)
  FROM Products;
#+END_SRC

#+RESULTS:
| count |
|-------|
|     8 |

** 对表进行分组

我们可以用 ~GROUP BY~ 子句像这样:

#+CAPTION: 根据品类对商品进行分组
#+BEGIN_EXAMPLE
| (厨房用具) |   (衣服)   |
|            |    T恤衫   |
|   菜刀     |   运动T恤  |
|   高压锅   +------------|
|   叉子     | (办公用品) |
|   擦菜板   |   打孔器   |
|            |   圆珠笔   |
#+END_EXAMPLE

对表进行切分, e.g.,

#+BEGIN_SRC sql
  SELECT product_type,
         COUNT(*) AS "该品类含有多少种商品"
  FROM Products
  GROUP BY product_type;
#+END_SRC

#+RESULTS:
| product_type | 该品类含有多少种商品 |
|--------------+------------------------|
| 衣服         | 2                    |
| 办公用品     | 2                    |
| 厨房用具     | 4                    |

在 ~GROUP BY~ 子句中指定的列称为​_聚合键_​/​_分组列_.
和 ~SELECT~ 子句一样, <<~GROUP BY~ 多列>> 可以通过逗号分隔以指定多列, 这些列的组合决定分组的方式.

N.b., ~GROUP BY~ 子句一定要写在 ~FROM~ (and if existing ~WHERE~) 子句之后[fn:SQL书写顺序].

*** 聚合键是 ~NULL~ 的情况

#+BEGIN_SRC sql :exports both
  SELECT regist_date /* 含 NULL */,
         COUNT(*) AS "该日登记的商品数目"
  FROM Products
  GROUP BY regist_date;
#+END_SRC

#+RESULTS:
| regist_date | 该日登记的商品数目 |
|-------------+----------------------|
|             | 1                  |
|  2009-11-11 | 1                  |
|  2009-09-20 | 3                  |
|  2009-09-11 | 1                  |
|  2009-01-15 | 1                  |
|  2008-04-28 | 1                  |

从结果可以看出, 当聚合键中包含 ~NULL~ 时, 也会将其作为一组特定的数据[fn:: 其实这是容易推理出来的, [[~GROUP BY~ 多列][前文]]说过, ~GROUP BY~ 子句可以指定多个分组列.  如果这些列的某一种组合中包含一个 ~NULL~ 列, 从情理上讲, 我们当然不应该舍弃这种组合; 而按照单列进行分组, 不过是按照多列的组合来进行分组的一种特例.].

*** 先过滤再分组

有 ~WHERE~ 子句时, 会先根据它指定的条件进行过滤, 然后再进行汇总.
E.g.,

#+BEGIN_SRC sql
  SELECT purchase_price,
         COUNT(*)
  FROM Products
  WHERE product_type = '衣服'
  GROUP BY purchase_price;
#+END_SRC

#+RESULTS:
| purchase_price | count |
|----------------+-------|
|            500 |     1 |
|           2800 |     1 |

总结一下上述 SQL 语句的执行顺序[fn:: 这与语法所规定的书写顺序并不相同.  就是这样的, 书写顺序 和 RDBMS 内部的执行顺序并不相同.]:
~FROM~ \to ~WHERE~ \to ~GROUP BY~ \to ~SELECT~.

* COMMENT File Local Variables

Local Variables:
eval: (w32-notification-close
       (w32-notification-notify :title "读到了第 115 页"
                                :body " "))
eval: (require 'ob-sql)
org-confirm-babel-evaluate: nil
sql-postgres-program: "D:/Progs/PostgreSQL/16/bin/psql.exe"
org-babel-default-header-args:sql: ((:engine . "postgresql")
                                    (:dbhost . "localhost")
                                    (:dbport . 5432)
                                    (:dbuser . "postgres")
                                    (:database . "shop"))
eval: (advice-add 'org-babel-execute:sql  ; and modify its definition when on MS-Windows.
                  :around (let ((my/PostgreSQL.org (current-buffer)))
                            (lambda (fn &rest args)
                              (with-environment-variables (("PGPASSWORD" (getenv "PGPASSWORD")))
                                (when (eq (current-buffer) my/PostgreSQL.org)
                                  (setenv "PGPASSWORD" " "))
                                (apply fn args))))
                  '((name . "~shynur/Documents/CheatSheets/PostgreSQL.org")))
eval: (browse-url-default-browser "file://localhost/D:/Desktop/ToRead/SQL基础教程-MICK/TextBook.pdf")
eval: (find-file-noselect "D:/Desktop/ToRead/SQL基础教程-MICK/src_ans/Answer/")
eval: (define-abbrev org-mode-abbrev-table
        "begsql" "#+BEGIN_SRC sql\n#+END_SRC"
        (lambda ()
          (previous-line 1)
          (end-of-line)))
eval: (abbrev-mode)
eval: (electric-quote-local-mode -1)
eval: (advice-add 'org-html-export-to-html :around
                  (let ((my/PostgreSQL.org (current-buffer)))
                    (lambda (fn &rest args)
                      (if (eq my/PostgreSQL.org (current-buffer))
                          (let ((using-light-theme? (memq 'modus-operandi custom-enabled-themes)))
                            (unless using-light-theme?
                              (load-theme 'modus-operandi))
                            (prog1 (apply fn args)
                              (unless using-light-theme?
                                (disable-theme 'modus-operandi))))
                        (apply fn args))))
                  '((name . "~shynur/Documents/CheatSheets/PostgreSQL.org")))
coding: utf-8-unix
End:
